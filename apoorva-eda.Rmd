---
title: "EDA TDSC"
author: "Apoorva Havanur"
date: "October 7, 2016"
output: html_document
---
```{r}
require(vcd)
require(MASS)
```

```{r}
data = read.csv('transaction_data_8451.csv')
View(data)
colnames(data)
length(unique(data$household_key))
length(unique(data$PRODUCT_ID))
unique(data$BASKET_ID)
purchases_matrix = data.frame()
for (basket in unique(data$BASKET_ID)) {
  purchases = data[which(data$BASKET_ID == basket),]
  purchase_vec = rep(0, length = length(unique(data$PRODUCT_ID)))
  for (j in 1:nrow(purchases)) {
    purchase = purchases[j,]
    index = which(unique(data$PRODUCT_ID) == purchase$PRODUCT_ID)
    purchase_vec[index] = purchase_vec[index] + 1
  }
  purchases_matrix = rbind(purchases_matrix, purchase_vec)
}
dim(purchases_matrix)
```
Cylicality
```{r}
# we're trying to find if the purchase of eggs for each household is "cylical". The way we're measuring this is by checking the days between each purchase of eggs, and then checking if the number of days in between has high or low variance. Ex. if a household buys a basket with eggs every 25 days exactly, we would call that cylical. But if one day they buy it, then the next day, and then 28 days later, then it would not be cylical. 
households = unique(data$household_key)
households_cycle_variance = c()
households_cycle_mean = c()
household_rate_coefficients = c()
last_egg_days = c()
for (i in 1:length(households)) {
  residual =  c()
  household = data[which(data$household_key == households[i]),]
  baskets = unique(household$BASKET_ID)
  num_baskets = length(baskets)
  contains_eggs_basket_ids = c()
  for (j in 1:num_baskets) {
    basket = household[which(household$BASKET_ID == baskets[j]),]
    if (sum(basket$COMMODITY_DESC == 'EGGS') > 0){
      contains_eggs_basket_ids = c(contains_eggs_basket_ids, basket$BASKET_ID)
    }
  }  
  egg_basket_days = c()
  for (egg_basket_id in 1:length(unique(contains_eggs_basket_ids))) {
    basket =  household[which(household$BASKET_ID == unique(contains_eggs_basket_ids)[egg_basket_id]),]
    basket_day = unique(basket$DAY)
    egg_basket_days = c(egg_basket_days, basket_day)
  }
  last_egg_days = c(last_egg_days, egg_basket_days[length(egg_basket_days)])
  day_differences = c()
  if (length(egg_basket_days) > 1) {
    for (basket_day_index in 2:length(egg_basket_days)) {
      day_differences = c(day_differences, egg_basket_days[basket_day_index] - egg_basket_days[basket_day_index-1])
    } 
  }
  else {
    day_differences = c(day_differences, mean(households_cycle_mean, na.rm = TRUE))
  }
  if (length(day_differences) > 1) {
    rate = fitdistr(na.omit(abs(day_differences - mean(day_differences))), "exponential")$estimate
    if (!is.na(rate)) {
    household_rate_coefficients = c(household_rate_coefficients, rate)
    }
    else {
       household_rate_coefficients = c(household_rate_coefficients, mean(household_rate_coefficients[-(which(is.na(household_rate_coefficients)))], na.rm = TRUE))
    }
  }
  else {
    household_rate_coefficients = c(household_rate_coefficients, mean(household_rate_coefficients[-(which(is.infinite(household_rate_coefficients)))], na.rm = TRUE))
  }
  households_cycle_variance = c(households_cycle_variance, sd(day_differences))
  households_cycle_mean = c(households_cycle_mean, mean(day_differences))
}

household_rate_coefficients
probs = c()
test = c()
train = c()
for (i in 1:length(households)) {
  household = data[which(data$household_key == households[i]),]
  baskets = unique(household$BASKET_ID)
  cutoff = sample(length(baskets), 1)
  cutoff_basket = household[which(household$BASKET_ID == baskets[cutoff]),]
  cutoff_day = unique(cutoff_basket$DAY)
  has_eggs = sum(cutoff_basket$COMMODITY_DESC == 'EGGS')
  test = c(test, has_eggs)
  last_egg_day = 0
  for (i in 1:length(baskets)) {
    if (i < cutoff) {
      basket = household[which(household$BASKET_ID == baskets[i]),]
      has_eggs = sum(basket$COMMODITY_DESC == 'EGGS')
      if (has_eggs > 0) {
        last_egg_day = unique(basket$DAY)
      } 
    }
  }
  prob = pexp(abs(cutoff_day - last_egg_day), rate = household_rate_coefficients[i]) - 0.01
  if (is.nan(prob)) {
    prob = 0.12768
  }
  if (is.na(prob)) {
    prob = 0.12768
  }
  probs = c(probs, prob)
}

hist(probs)
probs
```

```{r}
brier_score = function(data, test, vals) {
  households = unique(data$household_key)
  total = sum((vals - test)^2)/length(households)
  return (total)
}
```

```{r}
shoppers_that_day = c()
for (day in 1:length(unique(data$DAY))) {
  shoppers = length(unique(data$BASKET_ID[which(data$DAY == unique(data$DAY)[day])]))
  print (shoppers)
  shoppers_that_day = c(shoppers_that_day, shoppers)
}
lines(1:length(unique(data$DAY)), shoppers_that_day)
```

```{r}
households_cycle_mean[1]
pexp(15.54, households_cycle_mean[1], rate = (1/households_cycle_mean[1]))
```

```{r}
sizes = read.csv('HH_freqs.csv')
size_probs = sizes$prob_hhsize_eggs
calculate = function(data, size_probs, p_eggs) {
  avg_size_prob = mean(size_probs)
  cycle_probs = c()
  hh_size_prob = c()
  households = unique(data$household_key)
  return.df = data.frame(matrix(nrow = length(households)))
  return.df = cbind(return.df, households)
  for (i in 1:length(households)) {
    household = data[which(data$household_key == households[i]),]
    hh_size = unique(household$HOUSEHOLD_SIZE_DESC)
    if (!is.na(hh_size)) {
      if(hh_size == '5+') { 
        hh_size = 5
      }
      hh_size_prob = c(hh_size_prob, size_probs[which(sizes$sizes == hh_size)])
    }
    else {
      hh_size_prob = c(hh_size_prob, avg_size_prob)
    }
    baskets = unique(household$BASKET_ID)
    last_egg_day = 0
    for (i in 1:length(baskets)) {
      if (i < cutoff) {
        basket = household[which(household$BASKET_ID == baskets[i]),]
        has_eggs = sum(basket$COMMODITY_DESC == 'EGGS')
        if (has_eggs > 0) {
          last_egg_day = unique(basket$DAY)
        } 
      }
    }
    prob = pexp(abs(cutoff_day - last_egg_day), rate = household_rate_coefficients[i]) - 0.1
    if (is.nan(prob)) {
      prob = p_eggs
    }
    if (is.na(prob)) {
      prob = p_eggs
    }
    cycle_probs = c(cycle_probs, prob)
  }
  train = cycle_probs * hh_size_prob
  opp = (1-cycle_probs) * (1-hh_size_prob)
  vals = (train*p_eggs)/((train*p_eggs)+(opp)*(1-p_eggs))
  return (vals)
}

without_last_day = data[]
train = calculate(data, size_probs, 0.12768)


```

